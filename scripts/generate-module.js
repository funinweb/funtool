const fs = require("fs")
const path = require("path")

const SRC_DIR = path.resolve("./src")
const IGNORED_DIRS = ["__tests__", "__mocks__"]
const IGNORED_FILES = ["index.ts"]
const PACKAGE_JSON_PATH = path.resolve("./package.json")

// 获取 package.json 的版本信息
function getPackageVersion() {
	if (fs.existsSync(PACKAGE_JSON_PATH)) {
		const packageJson = JSON.parse(fs.readFileSync(PACKAGE_JSON_PATH, "utf-8"))
		return packageJson.version || "unknown"
	}
	return "unknown"
}

function capitalize(name) {
	return name.charAt(0).toUpperCase() + name.slice(1)
}

function isValidFile(fileName) {
	return (
		fileName.endsWith(".ts") &&
		!IGNORED_FILES.includes(fileName) &&
		!fileName.endsWith(".test.ts") &&
		!fileName.endsWith(".spec.ts")
	)
}

function getFunctionNames(filePath) {
	const content = fs.readFileSync(filePath, "utf-8")
  const functionNames = new Set()

  // 1. 匹配 export function foo(...) {...}
  const fnDeclMatches = content.matchAll(/export function (\w+)/g)
  for (const match of fnDeclMatches) {
    functionNames.add(match[1])
  }

  // 2. 匹配 export const foo = (...) => {...} 或 export const foo = function(...) {...}
  //    注意这里简单匹配了箭头函数和 function 表达式
  const constFnMatches = content.matchAll(
    /export const (\w+)\s*=\s*(?:\([^\)]*\)\s*=>|function\s*\()/g
  )
  for (const match of constFnMatches) {
    functionNames.add(match[1])
  }

  return [...functionNames]
}

function extractExistingNames(indexContent) {
	const exportMatches = [...indexContent.matchAll(/export\s+\{([^}]+)\}/g)]
	const names = new Set()

	for (const match of exportMatches) {
		const identifiers = match[1].split(",").map((s) => s.trim())
		identifiers.forEach((name) => {
			if (name) names.add(name)
		})
	}

	return names
}

function generateAutoContent(moduleDir, existingNames) {
	const absPath = path.join(SRC_DIR, moduleDir)
	const files = fs.readdirSync(absPath).filter((f) => isValidFile(f) && !IGNORED_DIRS.includes(f))
	const imports = []
	const exports = []
	const allNames = []

	for (const file of files) {
		const fileName = path.basename(file, ".ts")
		const fullPath = path.join(absPath, file)
		const functionNames = getFunctionNames(fullPath).filter((fn) => !existingNames.has(fn))

		if (functionNames.length > 0) {
			imports.push(`import { ${functionNames.join(", ")} } from './${fileName}';`)
			exports.push(`export { ${functionNames.join(", ")} } from './${fileName}';`)
			allNames.push(...functionNames)
		}
	}

	if (allNames.length === 0) return null

	const objectName = capitalize(moduleDir)
	const objectExport = `export const ${objectName} = {\n  ${allNames.join(",\n  ")}\n};`

	const sections = [
		// { title: 'Imports', content: imports.join('\n') },
		{ title: "Exports", content: exports.join("\n") },
		// { title: 'Object Export', content: objectExport }
	]
	return `// Auto-generated section (do not modify manually)\n
${sections.map((s) => `// ${s.title}\n${s.content}\n`).join("\n")}
// End of auto-generated section`
}

function updateIndexTs(moduleDir) {
	const indexPath = path.join(SRC_DIR, moduleDir, "index.ts")
	const original = fs.existsSync(indexPath) ? fs.readFileSync(indexPath, "utf-8") : ""
	const existingNames = extractExistingNames(original)

	const autoContent = generateAutoContent(moduleDir, existingNames)
	if (!autoContent) {
		console.log(`ℹ️  No new exports for ${moduleDir}/index.ts`)
		return
	}

	const start = original.indexOf("// Auto-generated section")
	const end = original.indexOf("// End of auto-generated section") + "// End of auto-generated section".length

	let newContent
	if (start !== -1 && end !== -1 && start < end) {
		newContent = original.slice(0, start) + autoContent + original.slice(end)
	} else {
		newContent = (original.trim() + "\n\n" + autoContent).trim()
	}

	fs.writeFileSync(indexPath, newContent + "\n", "utf-8")
	console.log(`✅ Updated: ${moduleDir}/index.ts`)
}

function updateMainIndexTs() {
	const mainIndexPath = path.join(SRC_DIR, "index.ts")
	const moduleDirs = fs.readdirSync(SRC_DIR).filter((d) => {
		const full = path.join(SRC_DIR, d)
		return fs.statSync(full).isDirectory() && !IGNORED_DIRS.includes(d)
	})

	const exports = moduleDirs.map((dir) => `export * from './${dir}';`).join("\n")

	const newIndexContent = `// Auto-generated by scripts/generate-module.js
export * from './version';

${exports}

// End of auto-generated section`

	fs.writeFileSync(mainIndexPath, newIndexContent, "utf-8")
	console.log("✅ Updated: src/index.ts")
}

function updateVersionFile() {
	const versionContent = `export const VERSION = '${getPackageVersion()}';\n`
	const versionPath = path.join(SRC_DIR, "version.ts")
	fs.writeFileSync(versionPath, versionContent, "utf-8")
	console.log("✅ Created/Updated: src/version.ts")
}

function main() {
	const moduleDirs = fs.readdirSync(SRC_DIR).filter((d) => {
		const full = path.join(SRC_DIR, d)
		return fs.statSync(full).isDirectory() && !IGNORED_DIRS.includes(d)
	})

	for (const dir of moduleDirs) {
		updateIndexTs(dir)
	}

	// Update the main index.ts with all module exports
	updateMainIndexTs()

	// Update the version.ts file
	updateVersionFile()
}

main()
